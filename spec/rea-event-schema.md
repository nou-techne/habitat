# REA Event Schema

*Sprint 20 — Cross-cutting: Interface specification for external consumers*

---

## Purpose

This document defines the event grammar that any system emitting economic events should follow to be compatible with the Habitat patronage accounting system. It is the interface contract between event producers (smart contracts, applications, agents) and event consumers (Treasury, People, Agreements tools).

If you are building a contract or service that generates economic activity relevant to a cooperative, emit events in this format and the accounting layer can consume them without translation.

---

## Design Principles

**1. REA grammar is the lingua franca.** Every event describes a Resource moving between Agents through an Event. No exceptions.

**2. Cumulative, not periodic.** Events accumulate. The system never penalizes gaps in activity. A member who contributes in Q1 and rests in Q2 has the same standing as one who contributes steadily across both.

**3. Federally legible.** Events should be meaningful to any REA-compatible system, not just one cooperative. Use standard types and identifiers. A sibling network should be able to read your events without custom translation.

**4. Immutable and append-only.** Events are facts. Corrections are new events, not mutations.

**5. Self-describing.** Each event carries enough context to be processed without requiring the consumer to query external state.

---

## Event Envelope

Every event, regardless of type, is wrapped in a standard envelope:

```
EventEnvelope
├── id              (bytes32 — unique event identifier)
├── timestamp       (uint256 — block.timestamp or off-chain ISO-8601)
├── networkId       (string — originating network, e.g., "clawsmos", "reacc", "techne")
├── sourceContract  (address — contract that emitted the event)
├── sourceChain     (uint256 — chain ID, e.g., 8453 for Base)
├── schemaVersion   (uint8 — currently 1)
└── payload         (EventPayload — the REA content)
```

The `networkId` field enables federation. A consumer receiving events from multiple networks can filter, aggregate, or route by origin.

---

## Event Payload (REA Core)

```
EventPayload
├── eventType       (string — see Event Types below)
├── resource
│   ├── type        (string — "ETH", "USD", "SERVICE_CREDIT", "LABOR_HOUR", etc.)
│   ├── amount      (uint256 or decimal — quantity, in smallest unit)
│   └── unit        (string — "wei", "USD_cents", "credits", "hours")
├── agentFrom
│   ├── id          (address or bytes32 — sender/contributor)
│   ├── role        (string — "member", "validator", "commons", "external")
│   └── networkId   (string — agent's home network, for federation)
├── agentTo
│   ├── id          (address or bytes32 — receiver/beneficiary)
│   ├── role        (string)
│   └── networkId   (string)
├── evidence
│   ├── txHash      (bytes32 — on-chain transaction hash, if applicable)
│   ├── uri         (string — link to deliverable, proof, or attestation)
│   └── contentHash (bytes32 — hash of evidence content for integrity)
└── memo            (string — human-readable description)
```

---

## Event Types

### Contribution Events

Events recording value flowing **into** the cooperative or commons.

| eventType | Description | agentFrom | agentTo |
|-----------|------------|-----------|---------|
| `contribution.cash` | Direct monetary contribution | contributor | cooperative |
| `contribution.labor` | Time/work contributed | contributor | cooperative |
| `contribution.in_kind` | Property or materials contributed | contributor | cooperative |
| `contribution.revenue` | Revenue generated by agent activity | contributor | cooperative |
| `contribution.community` | Governance, mentoring, validation work | contributor | cooperative |

### Flow Events

Events recording value moving **between** agents or accounts.

| eventType | Description | agentFrom | agentTo |
|-----------|------------|-----------|---------|
| `flow.allocation` | Patronage allocation (period-end) | cooperative | member |
| `flow.distribution` | Cash/token distribution to member | cooperative | member |
| `flow.transfer` | Transfer between agents | sender | receiver |
| `flow.fee` | Fee or commission | payer | recipient |
| `flow.split` | Revenue split (automated) | source | recipient |

### Commitment Events

Events recording stakes, commitments, and their resolution.

| eventType | Description | agentFrom | agentTo |
|-----------|------------|-----------|---------|
| `commitment.staked` | Agent stakes value on a commitment | staker | pool_contract |
| `commitment.resolved` | Commitment validated and resolved | pool_contract | staker |
| `commitment.slashed` | Commitment failed, stake forfeited | pool_contract | commons |
| `commitment.validated` | Validator votes on a commitment | validator | pool_contract |

### Governance Events

Events recording governance participation (non-monetary but patronage-relevant).

| eventType | Description | agentFrom | agentTo |
|-----------|------------|-----------|---------|
| `governance.vote` | Agent casts a governance vote | voter | proposal |
| `governance.proposal` | Agent submits a proposal | proposer | cooperative |
| `governance.consent` | Agent consents to a decision | consenter | decision |

---

## Solidity Interface

For on-chain event producers (smart contracts), emit this event:

```solidity
interface IHabitatEvents {
    /// @notice Emitted for every REA-compatible economic event
    /// @param eventId Unique identifier for this event
    /// @param eventType Type string (e.g., "contribution.labor", "flow.split")
    /// @param resourceType Resource identifier (e.g., "ETH", "SERVICE_CREDIT")
    /// @param amount Quantity in smallest unit
    /// @param agentFrom Source agent address
    /// @param agentTo Destination agent address
    /// @param evidence IPFS hash, tx hash, or URI of supporting evidence
    /// @param memo Human-readable description
    event HabitatEvent(
        bytes32 indexed eventId,
        string eventType,
        string resourceType,
        uint256 amount,
        address indexed agentFrom,
        address indexed agentTo,
        bytes32 evidence,
        string memo
    );
}
```

### Indexed Fields

Three fields are indexed for efficient filtering:
- `eventId` — look up a specific event
- `agentFrom` — all events where an agent contributed or sent
- `agentTo` — all events where an agent received

### Usage Example: Revenue Splitter

```solidity
contract RevenueSplitter is IHabitatEvents {
    function split() external {
        // ... calculate shares ...
        
        for (uint i = 0; i < recipients.length; i++) {
            // Transfer
            payable(recipients[i]).transfer(shares[i]);
            
            // Emit REA event
            emit HabitatEvent(
                keccak256(abi.encodePacked(block.number, i)),  // eventId
                "flow.split",                                    // eventType
                "ETH",                                           // resourceType
                shares[i],                                       // amount
                address(this),                                   // agentFrom
                recipients[i],                                   // agentTo
                bytes32(0),                                      // evidence
                "Automated revenue split"                        // memo
            );
        }
    }
}
```

---

## View Functions

Contracts that track cumulative contribution should expose these read functions for the People tool:

```solidity
interface IHabitatContribution {
    /// @notice Total cumulative contribution for an agent (all time, all types)
    /// @param agent The agent address
    /// @return Total contribution in base resource units (e.g., wei)
    function getCumulativeContribution(address agent) external view returns (uint256);
    
    /// @notice Cumulative contribution by type
    /// @param agent The agent address
    /// @param resourceType The resource type string
    /// @return Contribution amount for that resource type
    function getCumulativeContributionByType(address agent, string calldata resourceType) external view returns (uint256);
    
    /// @notice Agent's share of total contributions (basis points, 10000 = 100%)
    /// @param agent The agent address
    /// @return Share in basis points
    function getPatronageShare(address agent) external view returns (uint256);
    
    /// @notice Total number of unique contributors
    /// @return Count of agents with non-zero cumulative contribution
    function getContributorCount() external view returns (uint256);
}
```

### What These Functions Must NOT Do

- **No time-decay.** `getCumulativeContribution` returns the all-time total, not a weighted-average that penalizes inactivity.
- **No minimum-activity thresholds.** An agent with 1 wei of contribution has a valid (if tiny) patronage share.
- **No period-based filtering.** Cumulative means cumulative. Period-based queries are the consumer's responsibility, using event timestamps.

---

## Federation Protocol

For events to be legible across sibling networks:

**1. Use canonical resource types.** Prefer standard identifiers (`ETH`, `USD`, `LABOR_HOUR`) over network-specific names.

**2. Include `networkId` in the envelope.** This tells the consumer where the event originated.

**3. Agent addresses may differ across networks.** Use ENS names or cross-network identity registries (like `habitat.eth` subnames) for agent resolution when available.

**4. Events from federated networks are read-only.** A receiving network can observe and aggregate, but cannot modify or reject events from a sibling network. Trust is established at the network level, not the event level.

**5. Federated patronage is opt-in.** A cooperative decides which sibling networks' events count toward its patronage calculations. This is configured in the Agreements tool, not hardcoded.

---

## Mapping to Treasury Transactions

When the Treasury tool consumes a `HabitatEvent`, it generates double-entry transactions per the [Transaction Model](transaction-model.md):

| Event Type | Debit Account | Credit Account |
|-----------|--------------|----------------|
| `contribution.cash` | 1110 Operating / 1520 Streaming Tokens | 3100-{agent} Book Capital |
| `contribution.labor` | 5xxx Labor Expense (or capitalize) | 3100-{agent} Book Capital |
| `flow.split` | 1110 Source Account | 4xxx Revenue + member allocations |
| `flow.distribution` | 3100-{agent} Book Capital | 1110 Operating |
| `commitment.staked` | 1520 Staked Tokens | 2xxx Escrow Liability |
| `commitment.resolved` | 2xxx Escrow Liability | 1520 Staked Tokens (refund) |
| `commitment.slashed` | 2xxx Escrow Liability | 4xxx Commons Revenue |

The full mapping depends on the organization's chart of accounts configuration ([Chart of Accounts](chart-of-accounts.md)).

---

## Constraints for Contract Developers

If you are building a contract that participates in the Habitat ecosystem:

1. **Implement `IHabitatEvents`** — emit `HabitatEvent` for every state change that moves value
2. **Implement `IHabitatContribution`** if your contract tracks contributions — expose cumulative read functions
3. **Never implement time-decay** — the accounting layer handles temporal queries; the contract stores cumulative facts
4. **Use `evidence` field** — link to the deliverable, attestation, or proof that justifies the event
5. **Keep `memo` human-readable** — this appears in reports and dashboards
6. **Test with the schema validator** — (forthcoming: a tool that verifies your events parse correctly)

---

## Open Questions

- **Off-chain events:** How do non-blockchain events (Discord activity, GitHub commits, physical space work) get ingested? Likely through an oracle or attestation service that emits `HabitatEvent` on behalf of off-chain agents. Spec forthcoming.
- **Multi-token resources:** How do events involving multiple resource types in a single transaction get represented? Current design: one event per resource movement. A swap is two events.
- **Privacy:** Some contribution data (labor hours, compensation rates) may be sensitive. How do we balance transparency with privacy? Possible: hash sensitive fields, store plaintext in permissioned layer.

---

*Sprint 20 | February 8, 2026 | Habitat*
